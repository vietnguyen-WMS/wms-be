BEGIN;

-- 1) Schema + extensions
CREATE SCHEMA IF NOT EXISTS ums;

-- Extensions (ở schema public)
CREATE EXTENSION IF NOT EXISTS citext    WITH SCHEMA public;
CREATE EXTENSION IF NOT EXISTS pgcrypto  WITH SCHEMA public;

-- 2) Table: status_codes
CREATE TABLE IF NOT EXISTS ums.status_codes (
  id         SMALLSERIAL PRIMARY KEY,
  domain     TEXT        NOT NULL,   -- e.g., 'ums'
  code       TEXT        NOT NULL,   -- 'active','inactive','locked'
  name       TEXT        NOT NULL,
  is_active  BOOLEAN     NOT NULL DEFAULT TRUE,
  sort_order INT         NOT NULL DEFAULT 0,
  UNIQUE (domain, code)
);

-- 3) Helper function: get status_id by (domain, code)
CREATE OR REPLACE FUNCTION ums.get_status_id(p_domain TEXT, p_code TEXT)
RETURNS SMALLINT
LANGUAGE plpgsql
STABLE
AS $$
DECLARE
  v_id SMALLINT;
BEGIN
  SELECT id::SMALLINT
    INTO v_id
  FROM ums.status_codes
  WHERE domain = p_domain
    AND code   = p_code
  LIMIT 1;

  IF v_id IS NULL THEN
    RAISE EXCEPTION 'status code not found for domain=%, code=%', p_domain, p_code;
  END IF;

  RETURN v_id;
END
$$;

-- 3.1) Table: roles
CREATE TABLE IF NOT EXISTS ums.user_roles (
  id   SMALLSERIAL PRIMARY KEY,
  code TEXT NOT NULL UNIQUE,  -- 'admin','supervisor','operator'
  name TEXT NOT NULL
);

-- 3.2) Helper function: get role_id by code
CREATE OR REPLACE FUNCTION ums.get_role_id(p_code TEXT)
RETURNS SMALLINT
LANGUAGE plpgsql
STABLE
AS $$
DECLARE
  v_id SMALLINT;
BEGIN
  SELECT id::SMALLINT
    INTO v_id
  FROM ums.user_roles
  WHERE code = p_code
  LIMIT 1;

  IF v_id IS NULL THEN
    RAISE EXCEPTION 'role not found for code=%', p_code;
  END IF;

  RETURN v_id;
END
$$;

-- 4) Table: users
--    Add role_id (FK to user_roles), default = 'operator'
CREATE TABLE IF NOT EXISTS ums.users (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,

  username public.citext NOT NULL UNIQUE,
  password_hash TEXT NOT NULL,                         -- store only HASH

  status_id SMALLINT NOT NULL
           DEFAULT ums.get_status_id('ums','active')
           REFERENCES ums.status_codes(id),

  role_id SMALLINT NOT NULL
         DEFAULT ums.get_role_id('operator')
         REFERENCES ums.user_roles(id),

  failed_login_attempts INT NOT NULL DEFAULT 0 CHECK (failed_login_attempts >= 0),
  last_login_at TIMESTAMPTZ,
  last_password_change_at TIMESTAMPTZ,

  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  created_by BIGINT REFERENCES ums.users(id) ON DELETE SET NULL,

  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_by BIGINT REFERENCES ums.users(id) ON DELETE SET NULL,

  deleted_at TIMESTAMPTZ,

  CONSTRAINT username_not_blank CHECK (length(btrim(username::text)) > 0),
  CONSTRAINT pw_not_blank       CHECK (length(btrim(password_hash)) > 0)
);

-- Useful indexes for FK/lookups
CREATE INDEX IF NOT EXISTS idx_users_status_id  ON ums.users(status_id);
CREATE INDEX IF NOT EXISTS idx_users_role_id    ON ums.users(role_id);
CREATE INDEX IF NOT EXISTS idx_users_created_by ON ums.users(created_by);
CREATE INDEX IF NOT EXISTS idx_users_updated_by ON ums.users(updated_by);

-- 5) Trigger: auto-update updated_at on UPDATE (users)
CREATE OR REPLACE FUNCTION ums.tg_set_updated_at()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
  NEW.updated_at := NOW();
  RETURN NEW;
END
$$;

DROP TRIGGER IF EXISTS set_updated_at ON ums.users;
CREATE TRIGGER set_updated_at
BEFORE UPDATE ON ums.users
FOR EACH ROW
EXECUTE FUNCTION ums.tg_set_updated_at();

-- 4.1) Table user_info (1-1 với users) + trigger + view
CREATE TABLE IF NOT EXISTS ums.user_info (
  user_id      BIGINT PRIMARY KEY
               REFERENCES ums.users(id) ON DELETE CASCADE,

  -- fields that may be public
  first_name   TEXT,
  last_name    TEXT,

  -- Cho phép NULL; dùng biểu thức IMMUTABLE
  display_name TEXT GENERATED ALWAYS AS (
    NULLIF(
      btrim(
        coalesce(first_name, '') ||
        CASE WHEN first_name IS NOT NULL AND last_name IS NOT NULL THEN ' ' ELSE '' END ||
        coalesce(last_name, '')
      ),
      ''
    )
  ) STORED,

  avatar_url   TEXT,
  bio          TEXT,
  address      TEXT,

  -- flags controlling public visibility
  is_display_name_public BOOLEAN NOT NULL DEFAULT TRUE,
  is_avatar_public       BOOLEAN NOT NULL DEFAULT TRUE,
  is_bio_public          BOOLEAN NOT NULL DEFAULT TRUE,
  is_address_public      BOOLEAN NOT NULL DEFAULT FALSE,

  created_at   TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at   TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Trigger to update updated_at for user_info
CREATE OR REPLACE FUNCTION ums.tg_user_info_set_updated_at()
RETURNS TRIGGER
LANGUAGE plpgsql
AS $$
BEGIN
  NEW.updated_at := NOW();
  RETURN NEW;
END
$$;

DROP TRIGGER IF EXISTS set_updated_at ON ums.user_info;
CREATE TRIGGER set_updated_at
BEFORE UPDATE ON ums.user_info
FOR EACH ROW
EXECUTE FUNCTION ums.tg_user_info_set_updated_at();

-- VIEW: users_view exposes public user information
CREATE OR REPLACE VIEW ums.users_view AS
SELECT
  u.id AS id,
  u.username,
  CASE WHEN ui.is_display_name_public THEN ui.display_name END AS display_name,
  CASE WHEN ui.is_avatar_public       THEN ui.avatar_url   END AS avatar_url,
  CASE WHEN ui.is_bio_public          THEN ui.bio          END AS bio,
  CASE WHEN ui.is_address_public      THEN ui.address      END AS address
FROM ums.users u
LEFT JOIN ums.user_info ui ON ui.user_id = u.id;

-- 6) Seed minimal status codes
INSERT INTO ums.status_codes (domain, code, name, is_active, sort_order)
VALUES
  ('ums','active',   'Active',   TRUE, 1),
  ('ums','inactive', 'Inactive', TRUE, 2),
  ('ums','locked',   'Locked',   TRUE, 3)
ON CONFLICT (domain, code) DO UPDATE
SET name = EXCLUDED.name,
    is_active = EXCLUDED.is_active,
    sort_order = EXCLUDED.sort_order;

-- 6.1) Seed roles
INSERT INTO ums.user_roles (code, name) VALUES
  ('admin',      'Administrator'),
  ('supervisor', 'Supervisor'),
  ('operator',   'Operator')
ON CONFLICT (code) DO UPDATE
SET name = EXCLUDED.name;

-- 7) Seed/Upsert admin user với password 'admin@123', role = 'admin'
INSERT INTO ums.users (username, password_hash, status_id, role_id, created_at, updated_at)
VALUES (
  'admin',
  crypt('admin@123', gen_salt('bf')),
  ums.get_status_id('ums','active'),
  ums.get_role_id('admin'),
  NOW(),
  NOW()
)
ON CONFLICT (username) DO UPDATE
SET password_hash = EXCLUDED.password_hash,
    status_id     = EXCLUDED.status_id,
    role_id       = EXCLUDED.role_id,
    updated_at    = NOW();

-- 7.1) Seed/Upsert user 'viet' với password '1', role = 'admin'
INSERT INTO ums.users (username, password_hash, status_id, role_id, created_at, updated_at)
VALUES (
  'viet',
  crypt('1', gen_salt('bf')),
  ums.get_status_id('ums','active'),
  ums.get_role_id('admin'),
  NOW(),
  NOW()
)
ON CONFLICT (username) DO UPDATE
SET password_hash = EXCLUDED.password_hash,
    status_id     = EXCLUDED.status_id,
    role_id       = EXCLUDED.role_id,
    updated_at    = NOW();

-- Set created_by / updated_by to itself if NULL
UPDATE ums.users u
SET created_by = u.id,
    updated_by = u.id
WHERE u.username = 'admin'
  AND (u.created_by IS NULL OR u.updated_by IS NULL);

UPDATE ums.users u
SET created_by = u.id,
    updated_by = u.id
WHERE u.username = 'viet'
  AND (u.created_by IS NULL OR u.updated_by IS NULL);

-- 7.2) Seed/Upsert user_info for admin
WITH admin_row AS (
  SELECT id FROM ums.users WHERE username = 'admin' LIMIT 1
)
INSERT INTO ums.user_info (
  user_id, first_name, last_name, avatar_url, bio, address,
  is_display_name_public, is_avatar_public, is_bio_public, is_address_public,
  created_at, updated_at
)
SELECT
  ar.id,
  'System'::text,
  'Administrator'::text,
  NULL,
  'System administrator account',
  NULL,
  TRUE, TRUE, TRUE, FALSE,
  NOW(), NOW()
FROM admin_row ar
ON CONFLICT (user_id) DO UPDATE
SET
  first_name = EXCLUDED.first_name,
  last_name  = EXCLUDED.last_name,
  bio        = EXCLUDED.bio,
  updated_at = NOW();

-- 7.3) Seed/Upsert user_info for viet
WITH viet_row AS (
  SELECT id FROM ums.users WHERE username = 'viet' LIMIT 1
)
INSERT INTO ums.user_info (
  user_id, first_name, last_name, avatar_url, bio, address,
  is_display_name_public, is_avatar_public, is_bio_public, is_address_public,
  created_at, updated_at
)
SELECT
  vr.id,
  'Viet'::text,
  'Nguyen'::text,
  NULL,
  'Viet Nguyen administrator account',
  NULL,
  TRUE, TRUE, TRUE, FALSE,
  NOW(), NOW()
FROM viet_row vr
ON CONFLICT (user_id) DO UPDATE
SET
  first_name = EXCLUDED.first_name,
  last_name  = EXCLUDED.last_name,
  bio        = EXCLUDED.bio,
  updated_at = NOW();

COMMIT;
